# [Effective Java] item 59. 라이브러리를 익히고 사용하라

## Random 메서드
무작위 정수 하나를 생성하고 싶다고 해보자. 값의 범위는 0부터 명시한 수이다. 아주 흔히 마주치는 문제로, 많은 프로그래머가 다음과 같은 짤막한 메서드를 만들곤 한다.

##### 흔하지만 문제가 심각한 코드!
```java
static Random rnd = new Random();

static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}
```

괜찮은 듯 보여도 문제를 세 가지나 내포하고 있다. 

### Random 메서드의 결함
#### 첫 번째, n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.
#### 두 번째, n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다. n값이 크면 이 현상은 더 두드러진다.

다음 코드는 예시를 위해 필자가 신중히 선택한 범위에서 무작위 수를 백만개를 생성한 다음, 그중 중간 값보다 작은 게 몇 개인지를 출력한다.

```java
public static void main(String[] args) {
    int n = 2 * (Integer.MAX_VALUE / 3);
    int low = 0;
    for (int i = 0; i < 100000; i++)
        if (random(n) < n/2)
            low++;
    System.out.println(low);
}
```

random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로 돌려보면 666,666에 가까운 값을 얻는다. 무작위로 생성된 수 중에서 2/3 가량이 중간값보다 낮은 쪽으로 쏠린 것이다.

#### 세 번째, 지정된 범위 '바깥'의 수가 종종 튀어나올 수 있다. 
rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문이다. nextInt()가 Integer.MIN_VALUE를 반환하면 Math.abs도 Integer.MIN_VALUE를 반환하고, 나머지 연산자(%)은 음수를 반환해버린다(n이 2의 제곱수가 아닐 때의 시나리오다). 이렇게 되면 여러분의 프로그램은 실패할 것이고, 문제를 해결하고 싶어도 현상을 재현하기가 쉽지 않을 것이다.

이 결함을 해결하려면 의사난수 생성기, 정수론, 2의 보수 계산 등에 조예가 깊어야 한다. 다행히 여러분이 직접 해결할 필요는 없다. Random.nextInt(int)가 이미 해결해놨으니 말이다. 이 메서드의 자세한 동작 방식은 몰라도 된다 (궁금하다면 API문서나 소스코드를 살펴보기 바란다). 알고리즘에 능통한 개발자가 설계와 구현과 검증에 시간을 들여 개발했고, 이 분야의 여러 전문가가 잘 동작함을 검증해줬다. 그리고 이 라이브러리가 릴리스된 후 20여 년 가까이 수백만의 개발자가 열심히 사용했지만 버그가 보고된 적이 없다. 혹시 버그가 발견되더라도 다음 릴리스에서 수정될 것이다.

## 표준 라이브러리를 쓰는 이점

#### 첫 번째, 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.

자바 7부터는 Random을 더 이상 사용하지 않는게 좋다. `ThreadLocalRandom`으로 대체하면 대부분 잘 동작한다. Random보다 더 고품질의 무작위 수를 생성할 뿐만 아니라 속도도 더 빠르다. 한편 `포크-조인 풀이나 병렬 스트림에서는 SplittableRandom을 사용하라.`

#### 두 번째, 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
프로그래머들은 하부 공사를 하기보다는 어플리케이션 기능 개발에 집중하고 싶어 한다. 여러분도 마찬가지일 것이다.

#### 세 번째, 따로 노력하지 않아도 성능이 지속해서 개선된다는 점이다.
사용자가 많고, 업계 표준 벤치마크를 사용해 성능을 확인하기 위해 표준 라이브러리 제작자들은 더 나은 방법을 꾸준히 모색할 수밖에 없다. 자바 플랫폼 라이브러리의 많은 부분이 수 년에 걸쳐 지속해서 다시 작성되며, 때론 성능이 극적으로 개선되기도 한다.

#### 네 번째, 기능이 점점 많아진다.
라이브러리에 부족한 부분이 있다면 개발자 커뮤니티에서 이야기가 나오고 논의된 후 다음 릴리즈에 해당 기능이 추가되곤 한다.

#### 마지막으로, 여러분이 작성한 코드가 많은 사람에게 낯익은 코드가 된다.
자연스럽게 다른 개발자들이 더 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 된다.

## 자바 메이저 릴리즈에 추가되는 표준 라이브러리
이상의 이점들에 비춰볼 때 표준 라이브러리의 기능을 사용하는 것이 좋아 보이지만, 실상은 많은 프로그래머가 직접 구현해 쓰고 있다. 왜 그럴까? 아마도 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다. `메이저 릴리즈마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.` 자바는 메이저 릴리즈마다 새로운 기능을 설명하는 웹 페이지를 공시하는데, 한번 쯤 읽어볼 만 하다. 확실한 예를 보여주기 위해서, 지정한 URL의 내용을 가져오는 명령줄 어플리케이션을 작성해보겠다(리눅스의 curl 명령어를 생각하면 된다). 예전에는 작성하기가 까다로운 기능이었지만, 자바 9에서 InputStream에 추가된 transferTo 메서드를 사용하면 쉽게 구현할 수 있다. 다음은 transferTo를 이용해 이 기능을 '완벽히' 구현한 코드다.

##### transferTo메서드를 이용해 URL의 내용 가져오기 - 자바 9부터 가능하다.
```java
public static void main(String[] args) throws IOException {
    try (InputStream in = new URL(args[0]).openStrem()) {
        in.transferTo(System.out);
    }
}
```

라이브러리가 너무 방대하여 모든 API 문서를 공부하기는 벅차겠지만 `자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는  익숙해져야 한다.` 다른 라이브러리들은 필요할 때마다 익히기 바란다. 라이브러리는 매년 아주 빠르게 성장하고 있으니 모든 기능을 요약하는 건 무리다.

### 언급해둘 만한 라이브러리
1. 컬렉션 프레임워크
2. 스트림 라이브러리(아이템 45 ~ 48)
3. java.util.concurrent 동시성 기능
    - 멀티 스레드 프로그래밍 작업을 단순화해주는 고수준의 편의 기능
        - 능숙한 개발자가 자신만의 고수준 개념을 직접 구현할 수 있도록 도와주는 저수준 요소들을 제공

때때로 라이브러리가 여러분에게 필요한 기능을 충분히 제공하지 못할 수 있다. 더 전문적인 기능을 요구할수록 이런 일이 더 자주 생길 것이다. 우선은 라이브러리를 사용하려 시도해보자. 어떤 영역의 기능을 제공하는지 살펴보고, 여러분이 원하는 기능이 아니라 판단되면 대안을 사용하자. 어떤 라이브러리든 제공하는 기능은 유한하므로 항상 빈 구멍이 있기 마련이다. 자바 표준 라이브러리에서 원하는 기능을 찾지 못하면, 그 다음 선택지는 고품질의 서드파티 라이브러리가 될 것이다. 구글의 멋진 `구아바 라이브러리`가 대표적이다.[Guava] 적합한 서드파티 라이브러리도 찾지 못했다면, 다른 선택이 없으니 직접 구현하자.

## 핵심 정리
- 바퀴를 다시 발명하지 말자. 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 그런 라이브러리가 있다면, 쓰면 된다. 있는지 잘 모르겠다면 찾아보라. 
- 일반적으로 라이브러리의 코드는 여러분이 직접 작성한 것보다 품질이 좋고, 점차 개선될 가능성이 크다. 여러분의 실력을 폄하하는 게 아니다. 
- 코드 품질에도 규모의 경제에 적용된다. 즉, 라이브러리 코드는 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.

### 참고 자료
- Effective Java 3/E