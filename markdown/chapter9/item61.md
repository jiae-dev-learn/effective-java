# [Effective Java] item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

## 1. 자바의 데이터 타입
#### 기본 타입(primitive type)
- int, double, boolean 등
#### 박싱된 기본 타입
- Integer, Double, Boolean 등

## 2. 기본 타입과 박싱된 기본 타입의 차이점
오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니다.
#### 2.1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.
- 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.

#### 2.2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.

#### 2.3. 기본 타입이 박싱된 타입 보다 시간과 메모리 사용면에서 더 효율적이다.

---

## 3. 기본 타입과 박싱된 기본타입을 혼용할 때의 문제점

다음은 Integer 값을 오름차순으로 정렬하는 비교자다(복습해보자. 비교자의 compare 메서드는 첫 번째 원소가 두 번째 원소보다 작으면 음수, 같으면 0, 크면 양수를 반환한다). Integer는 그 자체로 순서가 있으니 이 비교자가 실질적인 의미는 없지만, 아주 흥미로운 점을 하나 보여준다.

##### 잘못 구현된 비교자 - 문제를 찾아보자!
```java
Comparator<Integer> naturalOrder = 
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```
별다른 문제를 찾기 어렵고, 실제로 이것저것 테스트해봐도 잘 통과한다. 예컨대 Collections.sort에 원소 백만 개짜리 리스트와 이 비교자를 넣어 돌려도 아무 문제가 없다. 리스트에 중복이 있어도 상관없다. 
```java
naturalOrder.compare(new Integer(42), new Integer(42))
```
하지만 심각한 결함이 숨어 있으니 바로 위와 같이 값을 출력하면 Integer 인스턴스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다. 즉 첫 번째 Integer가 두 번째보다 크다고 주장한다.

원인이 뭘까? naturalOrder의 `첫 번째 검사(i < j)`는 잘 작동한다. `여기서 i와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입 값으로 변환`된다. 그런 다음 첫 번째 정숫값이 두 번째 값보다 작은지를 평가한다. 

만약 작지 않다면 `두 번째 검사(i == j)`가 이뤄진다. 그런데 이 `두 번째 검사에서는 두 객체 참조'의 식별성을 검사`하게 된다. i와 j가 서로 다른 Integer 인스턴스라면 (비록 값은 같을지라도)  이 비교의 결과는 false가 되고, 비교자는 (잘못된 결과인) 1을 반환한다. 즉, 첫 번째 Integer 값이 두 번째보다 크다는 것이다. 이처럼 (같은 객체를 비교하는 게 아니라면) `박싱된 기본 타입에 ==연산자를 사용하면 오류가 일어난다.`

실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()`를 사용하자. 비교자를 직접 만들고 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다(아이템 14). 그렇더라도 이 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야 한다. 이렇게 하면 오류의 원인인 식별성 검사가 이뤄지지 않는다.

##### 문제를 수정한 비교자
```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // 오토 박싱
    return i < j ? -1 : (i == j ? 0 : 1);
};
```

---

이제 다음의 간단한 프로그램을 살펴보자.

##### 기이하게 동작하는 프로그램 - 결과를 맞혀보자!
```java
public class Unbelievable {
    static Integer i;
    
    public static void main(String[] args) {
        if (i == 42)
            System.out.println("믿을 수 없군!");
    }
}
```

이 프로그램은 "믿을 수 없군!"을 출력하지는 않지만 그만큼 기이한 결과를 보여준다. i == 42를 검사할 때 NullPointerException을 던지는 것이다. 원인은 i가 int가 아닌 Integer이며, 다른 참조 타입 필드와 마찬가지로 i의 초깃값도 null이라는 데 있다. 즉, i == 42는 Integer와 int를 비교하는 것이다. 거의 예외 없이 `기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.` 그리고 null 참조를 언박싱하면 NullPointerException이 발생한다. 이 예에서 보듯, 이런 일은 어디서든 벌어질 수 있다. 다행히 해법은 간단하다. i를 int로 선언해주면 끝이다.

---

이번에는 아이템 6의 코드 6-3을 다시 살펴보자.

##### 끔찍이 느리다! 객체가 만들어지는 위치를 찾았는가? - 코드 6-3과 같음
```java
public static void main(string[] args) {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```

이 프로그램은 실수로 지역변수 sum을 박싱된 기본 타입으로 선언하여 느려졌다. 오류나 경고 없이 컴파일되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.

이번 아이템에서 다룬 세 프로그램 모두 문제의 원인은 하나다. 프로그래머가 기본 타입과 박싱된 기본 타입의 차이를 무시한 대가를 치른 것이다. 처음 두 프로그램은 뼈아픈 실패로 이어졌고, 마지막은 심각한 성능 문제가 발생했다.

## 4. 박싱된 기본 타입은 언제 써야 하는가?
#### 4.1 컬렉션의 원소, 키, 값으로 사용할 때
- 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다. 더 일반화해 말하면, 매개변수화 타입이나 매개변수화 메서드(5장)의 타입 매개변수로는 박싱된 기본 타입을 써야 한다. 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다. 
- 예컨대 변수를 `ThreadLocal<int>` 타입으로 선언하는 건 불가능하며, 대신 `ThreadLocal<Integer>`로 써야 한다. 마지막으로, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.
#### 4.2 리플렉션을 통해 메서드를 호출할 때

## 핵심정리
- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
- 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
- 두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 여러분이 원한 게 아닐 가능성이 크다.
- 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 워지며, `언박싱 과정에서 NullPointerException을 던질 수 있다.
- 마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.

### 참고 자료
- Effective Java 3/E